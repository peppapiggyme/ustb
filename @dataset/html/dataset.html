
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>dataset</title><meta name="generator" content="MATLAB 8.2"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-01-28"><meta name="DC.source" content="dataset.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><pre class="codeinput"><span class="keyword">classdef</span> dataset &lt; handle
    <span class="comment">% dataset Superclass for different kinds of datasets</span>
    <span class="comment">%   dataset class contains all the information and methods that are</span>
    <span class="comment">%   common to all kinds of datasets. Datasets could be Synthetic transmit</span>
    <span class="comment">%   aperture (sta), Coherent plane wave (cpw), Virtual source (vs),</span>
    <span class="comment">%   and even image reconstructions (ir).</span>

    <span class="keyword">properties</span>  (SetAccess = public)
        name            <span class="comment">% String containing the name of the dataset</span>
        creation_date   <span class="comment">% String containing the date the dataset class was created</span>
        format = E.signal_format.IQ  <span class="comment">% Signal_format RF or IQ (enumerations.signal_format.RF, default=enumerations.signal_format.IQ)</span>
        geom            <span class="comment">% matrix M x 3 containing probe geometry [x, y, z] (m)</span>
        data            <span class="comment">% Matrix containing the numerical data. For acquisition</span>
                        <span class="comment">% datasets the matrix dimensions are [time_samples, channels, firings, frames]</span>
                        <span class="comment">% For image reconstruction datasets the matrix</span>
                        <span class="comment">% dimensions are [pixels, frames]</span>
        time            <span class="comment">% vector containing fast time (s)</span>
        c0              <span class="comment">% value conatining  the reference speed of sound (m/s)</span>
        modulation_frequency <span class="comment">% value conatining the modulation frequency (Hz), only required for IQ format</span>
    <span class="keyword">end</span>
    <span class="keyword">properties</span>  (SetAccess = protected)
        F               <span class="comment">% number of frames in the dataset</span>
        M               <span class="comment">% number of elements in the transducer</span>
        Nx              <span class="comment">% Number of pixel in the x direction (to be removed)</span>
        Nz              <span class="comment">% Number of pixel in the z direction (to be removed)</span>
        t0              <span class="comment">% initial time (s)</span>
        Fs              <span class="comment">% sampling frequency (Hz)</span>
        tx_apodization  <span class="comment">% matrix containing the apodization used for transmit</span>
        rx_apodization  <span class="comment">% matrix containing the apodization used for transmit</span>
        elapsed_time    <span class="comment">% elapsed time, for performance control</span>
    <span class="keyword">end</span>

    <span class="keyword">methods</span>  <span class="comment">% formating methods</span>
        <span class="keyword">function</span> set.time(h,input_time)
            <span class="keyword">if</span>(size(input_time,1)&lt;size(input_time,2))
                error(<span class="string">'The time vector must be a column vector!'</span>);
            <span class="keyword">else</span>
                h.time=input_time;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">methods</span> (Access = public)
        <span class="keyword">function</span> h = dataset(name)
            <span class="comment">% The constructor only requires the name of the dataset. It</span>
            <span class="comment">% automatically sets the creation date.</span>
            h.name=name;
            t_now=now;
            h.creation_date=[date sprintf(<span class="string">'-%d-%d-%d'</span>,hour(t_now),minute(t_now),round(second(t_now)))];
        <span class="keyword">end</span>

        <span class="keyword">function</span> [apo]= linear_apodization(h,beam,r)
            <span class="keyword">if</span> beam.apodization==E.apodization_type.none
                apo=ones(h.Nz,h.Nx,h.M);
            <span class="keyword">else</span>
                apo=zeros(h.Nz,h.Nx,h.M);
                Aperture=r.z./beam.FN;
                <span class="keyword">for</span> n=1:h.M
                    xd=abs(h.geom(n,1)-r.x+r.z*tan(beam.steer_angle));
                    <span class="keyword">switch</span>(beam.apodization)
                        <span class="keyword">case</span> E.apodization_type.boxcar
                            apo(:,:,n)=double(xd&lt;Aperture/2);
                        <span class="keyword">case</span> E.apodization_type.hanning
                            apo(:,:,n)=double(xd&lt;Aperture/2).*(0.5 + 0.5*cos(2*pi*xd./Aperture));
                        <span class="keyword">case</span> E.apodization_type.tukey25
                            roll=0.25;
                            apo(:,:,n)=(xd&lt;(Aperture/2*(1-roll))) + (xd&gt;(Aperture/2*(1-roll))).*(xd&lt;(Aperture/2)).*0.5.*(1+cos(2*pi/roll*(xd/Aperture-roll/2-1/2)));
                        <span class="keyword">case</span> E.apodization_type.tukey50
                            roll=0.5;
                            apo(:,:,n)=(xd&lt;(Aperture/2*(1-roll))) + (xd&gt;(Aperture/2*(1-roll))).*(xd&lt;(Aperture/2)).*0.5.*(1+cos(2*pi/roll*(xd/Aperture-roll/2-1/2)));
                        <span class="keyword">case</span> E.apodization_type.tukey80
                            roll=0.8;
                            apo(:,:,n)=(xd&lt;(Aperture/2*(1-roll))) + (xd&gt;(Aperture/2*(1-roll))).*(xd&lt;(Aperture/2)).*0.5.*(1+cos(2*pi/roll*(xd/Aperture-roll/2-1/2)));
                        <span class="keyword">otherwise</span>
                            error(<span class="string">'Unknown apodization type!'</span>);
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            <span class="comment">% implementation of Bastian's damping</span>
            <span class="keyword">if</span>(beam.damping)
                n0=1:(beam.damping+1);
                mask=(n0/(beam.damping+1)).^(1./beam.damping_order);
                <span class="keyword">for</span> nn=n0(1):n0(end) <span class="comment">% have to think on how to vectorise this</span>
                    apo(:,:,nn)=apo(:,:,nn).*mask(nn);
                    apo(:,:,end-nn+1)=apo(:,:,end-nn+1).*mask(nn);
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> [im]=envelope(h,sig)
            <span class="comment">% function [im]=envelope(h,sig)</span>
            <span class="keyword">switch</span>(h.format)
                <span class="keyword">case</span> E.signal_format.RF
                    warning(<span class="string">'Computing Hilbert transform on pixel data. Envelope may be inaccurate for low mesh resolution.'</span>);
                    im=zeros(h.Nz,h.Nx,h.F);
                    <span class="keyword">for</span> f=1:h.F
                        <span class="keyword">for</span> nx=1:h.Nx
                            im(:,nx,f)=abs(hilbert(sig(:,nx,f)));
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">case</span> E.signal_format.IQ
                    im=abs(sig);
                <span class="keyword">otherwise</span>
                    error(<span class="string">'Unknown signal format!'</span>);
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> show(h,r,input_im,dynamic_range)
            <span class="comment">% Ploting image reconstruction</span>
            im=20*log10(input_im./max(input_im(:)));
            figure; set(gca,<span class="string">'fontsize'</span>,16);
            <span class="keyword">for</span> f=1:h.F
                pcolor(r.x*1e3,r.z*1e3,im(:,:,f)); shading <span class="string">flat</span>; axis <span class="string">equal</span>; axis <span class="string">tight</span>; colormap <span class="string">gray</span>; caxis([-dynamic_range 0]);colorbar;
                xlabel(<span class="string">'x [mm]'</span>);
                ylabel(<span class="string">'z [mm]'</span>);
                set(gca,<span class="string">'YDir'</span>,<span class="string">'reverse'</span>);
                set(gca,<span class="string">'fontsize'</span>,16);
                axis([min(r.x(:)) max(r.x(:)) min(r.z(:)) max(r.z(:))]*1e3);
                title(sprintf(<span class="string">'%s (%s, %0.2fs/f)'</span>,char(h.name),char(h.format),h.elapsed_time/h.F));
                set(gcf,<span class="string">'Position'</span>,[680   618   640   480]);
                drawnow;
                pause(0.05);
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> [sig]=launch_implementation(h,r,imp)
            <span class="comment">% Launches appropriate implementation</span>
            <span class="keyword">switch</span>(imp)
                <span class="keyword">case</span> E.implementation.simple_matlab
                    sig=h.ir_simple_matlab(r);
                <span class="keyword">case</span> E.implementation.optimized_matlab
                    sig=h.ir_optimized_matlab(r);
                <span class="keyword">case</span> E.implementation.mex
                    sig=h.ir_mex(r);
                <span class="keyword">case</span> E.implementation.mex_gpu
                    sig=h.ir_mex_gpu(r);
                <span class="keyword">otherwise</span>
                    error(<span class="string">'Selected implementation is not supported'</span>);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">methods</span>
        <span class="keyword">function</span> sig=ir_simple_matlab(h,r)
            <span class="comment">% Simple Matlab implementation to be overloaded by subclasses</span>
            error(<span class="string">'Simple matlab: The implementation is not available yet!'</span>);
            sig=[];
        <span class="keyword">end</span>
        <span class="keyword">function</span> sig=ir_optimized_matlab(h,r)
            <span class="comment">% Simple Matlab implementation to be overloaded by subclasses</span>
            error(<span class="string">'Optimazed matlab: The implementation is not available yet!'</span>);
            sig=[];
        <span class="keyword">end</span>
        <span class="keyword">function</span> sig=ir_mex(h,r)
            <span class="comment">% Simple Matlab implementation to be overloaded by subclasses</span>
            error(<span class="string">'Mex: The implementation is not available yet!'</span>);
            sig=[];
        <span class="keyword">end</span>
        <span class="keyword">function</span> sig=ir_mex_gpu(h,r)
            <span class="comment">% Simple Matlab implementation to be overloaded by subclasses</span>
            error(<span class="string">'Mex gpu: The implementation is not available yet!'</span>);
            sig=[];
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2013b</a><br></p></div><!--
##### SOURCE BEGIN #####
classdef dataset < handle
    % dataset Superclass for different kinds of datasets
    %   dataset class contains all the information and methods that are
    %   common to all kinds of datasets. Datasets could be Synthetic transmit
    %   aperture (sta), Coherent plane wave (cpw), Virtual source (vs), 
    %   and even image reconstructions (ir).
    
    properties  (SetAccess = public)
        name            % String containing the name of the dataset
        creation_date   % String containing the date the dataset class was created
        format = E.signal_format.IQ  % Signal_format RF or IQ (enumerations.signal_format.RF, default=enumerations.signal_format.IQ)
        geom            % matrix M x 3 containing probe geometry [x, y, z] (m)
        data            % Matrix containing the numerical data. For acquisition
                        % datasets the matrix dimensions are [time_samples, channels, firings, frames]
                        % For image reconstruction datasets the matrix
                        % dimensions are [pixels, frames]
        time            % vector containing fast time (s)
        c0              % value conatining  the reference speed of sound (m/s)
        modulation_frequency % value conatining the modulation frequency (Hz), only required for IQ format
    end
    properties  (SetAccess = protected)   
        F               % number of frames in the dataset        
        M               % number of elements in the transducer
        Nx              % Number of pixel in the x direction (to be removed)
        Nz              % Number of pixel in the z direction (to be removed)
        t0              % initial time (s)
        Fs              % sampling frequency (Hz)
        tx_apodization  % matrix containing the apodization used for transmit
        rx_apodization  % matrix containing the apodization used for transmit
        elapsed_time    % elapsed time, for performance control
    end
    
    methods  % formating methods
        function set.time(h,input_time)
            if(size(input_time,1)<size(input_time,2))
                error('The time vector must be a column vector!');
            else
                h.time=input_time;
            end
        end
    end
    
    methods (Access = public)
        function h = dataset(name)
            % The constructor only requires the name of the dataset. It
            % automatically sets the creation date.
            h.name=name;
            t_now=now;
            h.creation_date=[date sprintf('-%d-%d-%d',hour(t_now),minute(t_now),round(second(t_now)))];
        end
        
        function [apo]= linear_apodization(h,beam,r)
            if beam.apodization==E.apodization_type.none
                apo=ones(h.Nz,h.Nx,h.M);
            else
                apo=zeros(h.Nz,h.Nx,h.M);
                Aperture=r.z./beam.FN;
                for n=1:h.M
                    xd=abs(h.geom(n,1)-r.x+r.z*tan(beam.steer_angle));
                    switch(beam.apodization)
                        case E.apodization_type.boxcar
                            apo(:,:,n)=double(xd<Aperture/2); 
                        case E.apodization_type.hanning
                            apo(:,:,n)=double(xd<Aperture/2).*(0.5 + 0.5*cos(2*pi*xd./Aperture)); 
                        case E.apodization_type.tukey25
                            roll=0.25;
                            apo(:,:,n)=(xd<(Aperture/2*(1-roll))) + (xd>(Aperture/2*(1-roll))).*(xd<(Aperture/2)).*0.5.*(1+cos(2*pi/roll*(xd/Aperture-roll/2-1/2)));                               
                        case E.apodization_type.tukey50
                            roll=0.5;
                            apo(:,:,n)=(xd<(Aperture/2*(1-roll))) + (xd>(Aperture/2*(1-roll))).*(xd<(Aperture/2)).*0.5.*(1+cos(2*pi/roll*(xd/Aperture-roll/2-1/2)));                               
                        case E.apodization_type.tukey80
                            roll=0.8;
                            apo(:,:,n)=(xd<(Aperture/2*(1-roll))) + (xd>(Aperture/2*(1-roll))).*(xd<(Aperture/2)).*0.5.*(1+cos(2*pi/roll*(xd/Aperture-roll/2-1/2)));                               
                        otherwise
                            error('Unknown apodization type!');
                    end
                end
            end
            % implementation of Bastian's damping
            if(beam.damping)
                n0=1:(beam.damping+1);                                  
                mask=(n0/(beam.damping+1)).^(1./beam.damping_order);
                for nn=n0(1):n0(end) % have to think on how to vectorise this
                    apo(:,:,nn)=apo(:,:,nn).*mask(nn);
                    apo(:,:,end-nn+1)=apo(:,:,end-nn+1).*mask(nn);
                end
            end
        end
        
        function [im]=envelope(h,sig)
            % function [im]=envelope(h,sig)
            switch(h.format)
                case E.signal_format.RF
                    warning('Computing Hilbert transform on pixel data. Envelope may be inaccurate for low mesh resolution.');
                    im=zeros(h.Nz,h.Nx,h.F);
                    for f=1:h.F
                        for nx=1:h.Nx
                            im(:,nx,f)=abs(hilbert(sig(:,nx,f)));
                        end
                    end
                case E.signal_format.IQ
                    im=abs(sig);
                otherwise
                    error('Unknown signal format!');
            end
        end
        
        function show(h,r,input_im,dynamic_range)
            % Ploting image reconstruction
            im=20*log10(input_im./max(input_im(:)));
            figure; set(gca,'fontsize',16);
            for f=1:h.F
                pcolor(r.x*1e3,r.z*1e3,im(:,:,f)); shading flat; axis equal; axis tight; colormap gray; caxis([-dynamic_range 0]);colorbar;
                xlabel('x [mm]');
                ylabel('z [mm]');
                set(gca,'YDir','reverse');
                set(gca,'fontsize',16);
                axis([min(r.x(:)) max(r.x(:)) min(r.z(:)) max(r.z(:))]*1e3);
                title(sprintf('%s (%s, %0.2fs/f)',char(h.name),char(h.format),h.elapsed_time/h.F)); 
                set(gcf,'Position',[680   618   640   480]);
                drawnow;
                pause(0.05);
            end
        end
        
        function [sig]=launch_implementation(h,r,imp)
            % Launches appropriate implementation
            switch(imp)
                case E.implementation.simple_matlab
                    sig=h.ir_simple_matlab(r);
                case E.implementation.optimized_matlab
                    sig=h.ir_optimized_matlab(r);
                case E.implementation.mex
                    sig=h.ir_mex(r);
                case E.implementation.mex_gpu
                    sig=h.ir_mex_gpu(r);
                otherwise
                    error('Selected implementation is not supported');
            end
        end
    end
    
    methods 
        function sig=ir_simple_matlab(h,r)
            % Simple Matlab implementation to be overloaded by subclasses
            error('Simple matlab: The implementation is not available yet!');
            sig=[];
        end
        function sig=ir_optimized_matlab(h,r)
            % Simple Matlab implementation to be overloaded by subclasses
            error('Optimazed matlab: The implementation is not available yet!');
            sig=[];
        end
        function sig=ir_mex(h,r)
            % Simple Matlab implementation to be overloaded by subclasses
            error('Mex: The implementation is not available yet!');
            sig=[];
        end
        function sig=ir_mex_gpu(h,r)
            % Simple Matlab implementation to be overloaded by subclasses
            error('Mex gpu: The implementation is not available yet!');
            sig=[];
        end
    end
end


##### SOURCE END #####
--></body></html>